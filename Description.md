**API MikroBILL**

**Список операторов и функций встроенного языка скриптов**

1.  Объявление локальных переменных (видны только в теле скрипта, в
    котором были объявлены):

> **var** имя\_переменной
>
> или
>
> **var** имя\_массива\[размер\_массива\]
>
> Объявление глобальных переменных. Изначально глобальные переменные
> должны быть объявлены в каком-то скрипте и этот скрипт должен быть
> запущен. После этого переменные станут доступны в любом скрипте.
> Глобальные переменные существуют до перезапуска сервиса MikroBILL.
>
> **global** имя\_переменной
>
> или
>
> **global** имя\_массива\[размер\_массива\]

1.  Условие

> **if** условие **then**

операторы, если условие верно

> **endif**

1.  Метки (переход выполнения в другую часть программы)

> **Goto имя\_метки**
>
> **Пример:**
>
> // Это бесконечный цикл
>
> loop1:
>
> *alert*((**"Hello, world!"**)
>
> c=c+1
>
> **if** (c&lt;a) **then** **goto** loop1

1.  Комментарий:

> Операторы, находящиеся правее символов: // считаются комментарием к
> коду и не выполняются

1.  Дополнительные служебные слова:

> **Nothing –** ничто, неопределённое значение
>
> **End** или **Exit** - Немедленное завершение скрипта

1.  Спецсимволы в тексте (для MikroBILL 2.0.11 и новее):

2.  В тексте можно использовать \\ для передачи кавычек, например:

> **"{\\Name\\: \\User\\}**

1.  Текст, содержащий несколько строк можно передать так:

> имя\_переменной = **"Первая строка**
>
> **Вторая строка"**

Пример удалённого управления MikroBILL при помощи языков
программирования вы можете найти в файле “Программирование.doc”.

Ниже представлен список специальных операторов MikroBILL.

> Обратите внимание, в качестве параметров вы можете использовать либо
> строки (они ограничиваются кавычками), либо функции с любым
> количеством вложений, например:
>
> *StartClients*(**"Логин1"**,*GetClientFromIP*(**"10.10.0.2"**)) //
> Запуск клиента с логином Логин1 и клиента, чей IP = 10.10.0.2

В описании некоторых функций вы можете видеть некоторые параметры в
\[квадратных скобках\]. Так обозначаются параметры, которые в функцию
передавать не обязательно. При вызове функции из скрипта квадратные
скобки писать не нужно.

> Примеры работы со строками и математические операторы:
>
> Склейка строк: "Hot" & "Dog" - Результат: HotDog
>
> Математические операции: (2 + 2) \* 3 – 7 - Результат: 5
>
> **Список функций:**
>
> *RemoveClients*(**"Логин1"**,\[**"Логин2"**\],\[**"Логин3"**\],...) //
> Удаление, выбранных клиентов
>
> *StopClients*(**"Логин1"**,\[**"Логин2"**\],\[**"Логин3"**\],...) //
> Остановка, выбранных клиентов
>
> *StartClients*(**"Логин1"**,\[**"Логин2"**\],\[**"Логин3"**\],...) //
> Запуск, выбранных клиентов
>
> *StartReserving*(**"Логин1"**,\[**"Логин2"**\],\[**"Логин3"**\],...)
> // Включение резервирования абонентской линии для указанных клиентов
>
> *StopReserving*(**"Логин1"**,\[**"Логин2"**\],\[**"Логин3"**\],...) //
> Отключение резервирования абонентской линии для указанных клиентов
>
> *AddClient*(**"Внутреннее имя"**, **"Логин"**, **"Пароль"**, **"IP"**,
> **"Тариф"**) // Создание нового клиента
>
> *EditClient*(**"Прежнее внутреннее имя"**, **"Новое внутреннее имя"**,
> **"Новый логин"**, **"Новый пароль"**, **"IP"**, **"Дата1"**,
> **"Дата2"**, **"Dial IN"**) // Редактирование выбранного клиента
>
> *SetLimits*(Лимит\_вх\_скорости,Лимит\_исх\_скорости,\[**"Логин1"**\],\[**"Логин2"**\],...)
> // Устанавливает ограничения скорости, выбранным абонентам. Если
> ограничение скорости выбрано в тарифе, устанавливаются персональные
> ограничения. Чтобы снять персональные ограничения, передайте в функцию
> ограничения равные -1.
>
> *SetTarif*(**"Имя тарифа"**,\[**"Логин1"**\],\[**"Логин2"**\],...) //
> Изменяет тариф выбранным клиентам
>
> *GetTarif*(**"Логин клиента"**) // Получает тариф клиента
>
> *GetPrevTarif*(**"Логин клиента"**) // Получает предыдущий тариф
> клиента
>
> *SetGroup*(**"Имя группы"**,\[**"Логин1"**\],\[**"Логин2"**\],...) //
> Изменяет группу выбранным клиентам
>
> *GetGroup*(**"Логин клиента"**) // Получает группу клиента
>
> *SetPersonalInfo*(**"Логин"**, **"Договор"**, **"ФИО"**,
> **"Паспорт"**, **"Адрес"**, **"Сотовый тел."**, **"Email"**) //
> Устанавливает персональные данные выбранному клиенту
>
> *ResetTraffic*(**"Логин1"**,\[**"Логин2"**\],\[**"Логин3"**\],...) //
> Сбрасывает наработанный клиентами общий трафик
>
> *ResetDayTraffic*(**"Логин1"**,\[**"Логин2"**\],\[**"Логин3"**\],...)
> // Сбрасывает наработанный клиентами суточный трафик
>
> *ResetMonthTraffic*(**"Логин1"**,\[**"Логин2"**\],\[**"Логин3"**\],...)
> // Сбрасывает наработанный клиентами месячный трафик
>
> *SetTraffic*(**"Логин"**, входящих\_байт, исходящих\_байт) //
> Устанавливает наработанный клиентами общий трафик
>
> *SetDayTraffic*(**"Логин"**, входящих\_байт, исходящих\_байт) //
> Устанавливает наработанный клиентами суточный трафик
>
> *SetMonthTraffic*(**"Логин"**, входящих\_байт, исходящих\_байт) //
> Устанавливает наработанный клиентами месячный трафик
>
> *Disconnect*(**"Логин1"**,\[**"Логин2"**\],\[**"Логин3"**\],...) //
> Сбрасывает соединение для PPP и HotSpot абонентов.
>
> *SendSMS*(**"Текст сообщения"**,\[**"Логин1"**\],\[**"Логин2"**\],...)
> // Отправляет SMS клиенту
>
> *SendMail*(**"Текст
> сообщения"**,\[**"Логин1"**\],\[**"Логин2"**\],...) // Отправляет
> email клиенту
>
> *SendMail2*(**"Имя шаблона
> HTML"**,\[**"Логин1"**\],\[**"Логин2"**\],...) // Отправляет email
> клиенту
>
> *CreateTelnetConnection*(**"IP"**, Порт, **"Логин"**, **"Пароль"**) //
> Создаёт новое подключение по Telnet, возвращает ID подключения (ID
> существует до окончания выполнения скрипта) Если соединение удачное,
> возвращается число типа long, если подключение не удалось,
> возвращается 0.
>
> *TelnetSend*(ID\_Telnet\_подключения,**"Telnet команда
> №1"**,\[**"Telnet команда №2"**\],...) // Отправляет Telnet команду.
> ID подключения = IP подключения + порт, например: 192.168.100.1:23
> (только для Telnet подключений, добавленных через интерфейс
> MikroBILL).
>
> *TelnetSendSync*(ID\_Telnet\_подключения,**"Telnet команда"**,
> \[Имя\_массива\], \[Индикатор\_строки\]) // Отправляет Telnet команду.
> ID подключения = IP подключения + порт, например: 192.168.100.1:23
> (только для Telnet подключений, добавленных через интерфейс
> MikroBILL). Также ID может быть идентификатором, созданным функцией
> CreateTelnetConnection. Возвращает данные либо в переменную, либо в
> строковый массив. Индикатор\_строки: если параметр не задан, то данные
> передаются как строка (оканчиваются символом переноса каретки), если
> параметр равен true, то данные передаётся по telnet без символа
> переноса каретки.
>
> *CreateSSHConnection*(**"IP"**, Порт, **"Логин"**, **"Пароль"**) //
> Создаёт новое подключение по SSH, возвращает ID подключения (ID
> существует до окончания выполнения скрипта) Если соединение удачное,
> возвращается число типа long, если подключение не удалось,
> возвращается 0.
>
> *SSHSend*(ID\_SSH\_подключения,**"SSH команда №1"**,\[**"SSH команда
> №2"**\],...) // Отправляет SSH команду. ID подключения = IP
> подключения + порт, например: 192.168.100.1:22 (только для SSH
> подключений, добавленных через интерфейс MikroBILL).
>
> *SSHSendSync*(ID\_SSH\_подключения,**"SSH команда"**,
> \[Имя\_массива\], \[Индикатор\_строки\]) // Отправляет SSH команду. ID
> подключения = IP подключения + порт, например: 192.168.100.1:22
> (только для SSH подключений, добавленных через интерфейс MikroBILL).
> Также ID может быть идентификатором, созданным функцией
> CreateSSHConnection. Возвращает данные либо в переменную, либо в
> строковый массив. Индикатор\_строки: если параметр не задан, то данные
> передаются как строка (оканчиваются символом переноса каретки), если
> параметр равен true, то данные передаётся по SSH без символа переноса
> каретки.
>
> *CreateFTPConnection*(**"IP или хост"**, **"Логин"**, **"Пароль"**) //
> Создаёт новое подключение по FTP, возвращает ID подключения (ID
> существует до окончания выполнения скрипта). Если соединение удачное,
> возвращается число типа long, если подключение не удалось,
> возвращается 0.
>
> *FTPUploadFile*(ID\_FTP\_подключения, **"Путь к файлу"**,**"FTP
> путь"**) // Загружает файл на FTP. Если такой файл присутствует, файл
> перезаписывается. Файлы можно загружать только из папки
> %allusersprofile%\MikroBILL\Scripts\Files\\
>
> *FTPDownloadFile*(ID\_FTP\_подключения, **"FTP путь"**,**"Локальный
> путь к файлу"**) // Скачивает файл с FTP-сервера на локальный ПК. Если
> такой файл присутствует, файл перезаписывается. Файлы загружаются
> только в папку %allusersprofile%\MikroBILL\Scripts\Files\\
>
> *FTPUploadDirectory*(ID\_FTP\_подключения, **"Путь к
> каталогу"**,**"FTP путь"**) // Загружает каталог на FTP. Если
> какой-либо файл присутствует на FTP сервере, он будет перезаписан.
> Загрузка может происходить только из папки
> %allusersprofile%\MikroBILL\Scripts\Files\\
>
> *MakeDataExport*(**"Имя файла"**,\[**"Логин"**\], \[**"Тариф"**\],
> \[**"Группа"**\],\[**"Набор\_Столбцов"**\],\[**"Разделитель"**\],\[**"Кодировка"**\])
> // Экспортирует данные в файл по всем абонентам. Экспорт может
> происходить только в папку %allusersprofile%\MikroBILL\Scripts\Files\\
> Порядок формирования параметра «Набор столбцов» вы найдёте в конце
> этого файла. Разделитель – символ, разделяющий данные, по умолчанию
> это точка с запятой ';'.
>
> *MakeDataImport*(**"Имя
> файла"**,\[**"Набор\_Столбцов"**\],\[**"Разделитель"**\],\[Создавать\_клиентов\],\[Заменять\_баланс\],\[**"Кодировка"**\])
> // Импортирует данные из файла. Импорт может происходить только из
> папки %allusersprofile%\MikroBILL\Scripts\Files\\ Порядок формирования
> параметра «Набор столбцов» вы найдёте в конце этого файла. Разделитель
> – символ, разделяющий данные, по умолчанию это точка с запятой ';'.
> Параметр Создавать\_клиентов принимает False или True и показывает,
> нужно ли создавать клиентов, если клиент не найден. Параметр
> Заменять\_баланс принимает False или True, если значение True вместо
> пополнения баланс абонента будет заменён.
>
> *ResetCallerID*(**"Логин1"**,**"IP"**,...) // Сбрасывает CallerID
> клиенту для заданного IP
>
> *ResetChangeTarifDate*(**"Логин1"**,\[**"Логин2"**\],...) //
> Сбрасывает дату смены тарифа
>
> *GetClientFromPhone*(**"Номер телефона"**) // Выводит логин клиента, с
> заданным номером сотового телефона
>
> *GetClientFromPhone2*(**"Номер телефона"**) // Выводит логин клиента,
> с заданным номером домашнего телефона
>
> *GetClientFromContract*(**"Номер договора"**) // Выводит логин
> клиента, с заданным номером договора (поиск идёт без префикса)
>
> *GetClientFromIP*(**"IP-адрес"**) // Выводит логин клиента, с заданным
> номером договора
>
> *GetClientFromICQ*(**"Номер ICQ"**) // Выводит логин клиента, с
> заданным номером ICQ
>
> *GetClientFromMail*(**"Почта"**) // Выводит логин клиента, с заданным
> email
>
> *GetClientPassword*(**"Логин клиента"**) // Получает пароль клиента
>
> *SetClientPassword*(**"Логин клиента"**, **"Новый пароль"**) //
> Устанавливает пароль клиента
>
> *GetClientIP*(**"Логин клиента"**) // Получает IP клиента
>
> *SetClientIP*(**"Логин клиента"**, **"Новый IP"**) // Устанавливает IP
> клиента
>
> *IsWhiteIP*(**"Логин клиента"**, **"IP"**) // Проверяет, отмечен ли IP
> клиента, как белый
>
> *SetWhiteIP*(**"Логин клиента"**, **"IP",** True\_или\_false) //
> Отмечает IP клиента, как белый, или снимает отметку.
>
> *RenewClientIP*(**"Логин клиента"**, \[**"Название пула"**\]) //
> Находит первый свободный IP в указанном пуле и устанавливает его
> клиенту. Если пул не указан, то IP берётся из любого пула
>
> *GetFirstFreeIP*(\[**"Название пула"**\], \[Порядковый\_номер\]) //
> Получает свободный IP из указанного пула с указанным порядковым
> номером.
>
> *isFreeIP*(**"IP"** \[**"Название пула"**\]) // Проверяет, свободен ли
> IP.
>
> *GetFirstFreeLogin*(\[Порядковый\_номер\]) // Получает первый
> свободный логин с указанным порядковым номером.
>
> *GetFirstFreeContract*(\[Порядковый\_номер\]) // Получает первый
> свободный договор с указанным порядковым номером.
>
> *GetClientMAC*(**"Логин клиента"**) // Получает MAC клиента
>
> *SetClientMAC*(**"Логин клиента"**, **"Новый MAC"**) // Устанавливает
> MAC клиента
>
> *GetClientDate1*(**"Логин клиента"**) // Получает дату старта клиента
>
> *SetClientDate1*(**"Логин клиента"**, **"Новая дата"**) //
> Устанавливает дату старта клиента
>
> *GetClientDate2*(**"Логин клиента"**) // Получает дату остановки
> клиента
>
> *SetClientDate2*(**"Логин клиента"**, **"Новая дата"**) //
> Устанавливает дату остановки клиента
>
> *DaysToStop*(**"Логин клиента"**) // Возвращает количество дней до
> остановки клиента
>
> *DateToStop*(**"Логин клиента"**) // Возвращает предполагаемую дату
> остановки клиента
>
> *AddDays*(Количество\_добавляемых\_дней,\[**"Логин1"**\],\[**"Логин2"**\],...)
> // Добавляет дни к дате остановки клиента
>
> *GetClientLimitRx*(**"Логин клиента"**) // Получает ограничения
> входящей скорости клиента, установленные в текущий момент
>
> *GetClientLimitTx*(**"Логин клиента"**) // Получает ограничения
> исходящей скорости клиента, установленные в текущий момент
>
> *GetTarifLimitRx*(**"Тариф"**) // Получает ограничения входящей
> скорости клиента, установленные в тарифе в текущий момент
>
> *GetTarifLimitTx*(**"Тариф"**) // Получает ограничения исходящей
> скорости клиента, установленные в тарифе текущий момент
>
> *GetClientCurrentLimitRx*(**"Логин клиента"**) // Получает текущие
> ограничения входящей скорости клиента, действующие в программе
>
> *GetClientCurrentLimitTx*(**"Логин клиента"**) // Получает текущие
> ограничения исходящей скорости клиента, действующие в программе
>
> *GetClientBurstProz*(**"Логин клиента"**) // Получает размер бурста
> для выбранного клиента
>
> *SetClientBurstProz*(**"Логин клиента"**, **"Нововый бурст"**) //
> Устанавливает размер бурста для выбранного клиента
>
> *GetClientBurstTime*(**"Логин клиента"**) // Получает время бурста для
> выбранного клиента
>
> *SetClientBurstTime*(**"Логин клиента"**, **"Новое время бурста"**) //
> Устанавливает время бурста для выбранного клиента
>
> *GetClientPriority*(**"Логин клиента"**) // Получает приоритет трафика
> для выбранного клиента
>
> *SetClientPriority*(**"Логин клиента"**, **"Новый приоритет"**) //
> Устанавливает приоритет трафика для выбранного клиента
>
> *GetClientContract*(**"Логин клиента"**) // Получает № договора для
> выбранного клиента (с префиксом)
>
> *GetClientContract2*(**"Логин клиента"**) // Получает № договора для
> выбранного клиента (без префикса)
>
> *SetClientContract*(**"Логин клиента"**, **"Новый договор"**) //
> Устанавливает № договора для выбранного клиента (без префикса)
>
> *GetClientFIO*(**"Логин клиента"**, \[Массив\]) // Получает ФИО
> клиента одной строкой. Если задана переменная массив, то фамилия, имя
> и отчество загружается в массив в отдельные ячейки.
>
> *SetClientFIO*(**"Логин клиента"**, **"Новые ФИО"**) // Устанавливает
> ФИО клиента
>
> *GetClientAddress*(**"Логин клиента"**) // Получает адрес подключения
> клиента
>
> *SetClientAddress*(**"Логин клиента"**, **"Новый адрес"**) //
> Устанавливает адрес подключения клиента
>
> *GetClientAddress2*(**"Логин клиента"**) // Получает адрес проживания
> клиента
>
> *SetClientAddress2*(**"Логин клиента"**, **"Новый адрес"**) //
> Устанавливает адрес проживания клиента
>
> *GetClientPhone*(**"Логин клиента"**) // Получает сотовый телефон
> клиента
>
> *SetClientPhone*(**"Логин клиента"**, **"Новый телефон"**) //
> Устанавливает сотовый телефон клиента
>
> *GetClientPhone2*(**"Логин клиента")** // Получает домашний телефон
> клиента
>
> *SetClientPhone2*(**"Логин клиента"**, **"Новый телефон"**) //
> Устанавливает домашний телефон клиента
>
> *GetClientPassport*(**"Логин клиента"**) // Получает паспортные данные
> клиента
>
> *SetClientPassport*(**"Логин клиента"**, **"Новый паспорт"**) //
> Устанавливает паспортные данные клиента
>
> *GetClientMail*(**"Логин клиента"**) // Получает почтовый ящик клиента
>
> *SetClientMail*(**"Логин клиента"**, **"Новая почта"**) //
> Устанавливает почтовый ящик клиента
>
> *GetClientICQ*(**"Логин клиента"**) // Получает ICQ клиента
>
> *SetClientICQ*(**"Логин клиента"**, **"Новая ICQ"**) // Устанавливает
> ICQ клиента
>
> *GetClientComment*(**"Логин клиента"**) // Получает комментарий
> клиента
>
> *SetClientComment*(**"Логин клиента"**, **"Новый комментарий"**) //
> Устанавливает комментарий клиента
>
> *GetClientComment2*(**"Логин клиента"**) // Получает комментарий №2
> клиента
>
> *SetClientComment2*(**"Логин клиента"**, **"Новый комментарий"**) //
> Устанавливает комментарий №2 клиента
>
> *GetClientComment3*(**"Логин клиента"**) // Получает комментарий №3
> клиента
>
> *SetClientComment3*(**"Логин клиента"**, **"Новый комментарий"**) //
> Устанавливает комментарий №3 клиента
>
> *GetClientComment4*(**"Логин клиента"**) // Получает комментарий №4
> клиента
>
> *SetClientComment4*(**"Логин клиента"**, **"Новый комментарий"**) //
> Устанавливает комментарий №4 клиента
>
> *QuickCommandStart*(**"Логин клиента"**, **"Название быстрой
> команды"**) // Запускает быструю команду. Действует только для команд,
> выполняемых на серверной стороне.
>
> *TriggerStart*(**"Логин клиента"**, **"Название триггера"**) //
> Запускает быструю команду. Действует только для команд, выполняемых на
> серверной стороне.
>
> *GetClientField*(**"Логин клиента"**, **"Название поля"**) // Получает
> значение из дополнительного поля
>
> *SetClientField*(**"Логин клиента"**, **"Название поля"**, **"Новое
> значение"**) // Устанавливает значение из дополнительного поля
>
> *SetPersonalInformation* (**"Логин клиента"**, **"Информационное
> сообщение"**) // Устанавливает персональную информацию для клиента
>
> *GetPersonalInformation* (**"Логин клиента "**) // Получает
> персональную информацию клиента
>
> *SetPersonalInformation2* (**"Логин клиента"**, **"Информационное
> сообщение"**) // Устанавливает дополнительную персональную информацию
> для клиента
>
> *GetPersonalInformation2* (**"Логин клиента "**) // Получает
> дополнительную персональную информацию клиента
>
> *SetPersonalFee*(**"Логин клиента"**, Алгоритм, размер\_оплаты,
> \[дни\_до\_отключения\]) // Устанавливает персональную абонентскую
> плату (Алгоритм: 0 – Как на текущем тарифе, 1 – процент от заданного в
> тарифе, 2 – абсолютное значение, 3 – фиксированная скидка). Если дни
> до отключения персональной оплаты – 0, то персональная абонентская
> плата никогда не закончится.
>
> *GetPersonalFee*(**"Логин клиента"**) // Возвращает размер
> персональной абонентской платы
>
> *GetPersonalFeeAlgoritm*(**"Логин клиента"**) // Возвращает алгоритм
> персональной абонентской платы (0 – Как на текущем тарифе, 1 – процент
> от заданного в тарифе, 2 – абсолютное значение)
>
> *SetServicePersonalFee*(**"Логин клиента"**, **"Название услуги"**,
> Алгоритм, размер\_оплаты, \[дни\_до\_отключения\]) // Устанавливает
> персональную абонентскую плату (Алгоритм: 0 – Как в текущей услуге, 1
> – процент от заданного в услуге, 2 – абсолютное значение, 3 –
> фиксированная скидка). Если дни до отключения персональной оплаты – 0,
> то персональная абонентская плата никогда не закончится.
>
> *GetServicePersonalFee*(**"Логин клиента"**, **"Название услуги"**) //
> Возвращает размер персональной абонентской платы
>
> *GetServicePersonalFeeAlgoritm*(**"Логин клиента"**, **"Название
> услуги"**) // Возвращает алгоритм персональной абонентской платы (0 –
> Как в текущей услуге, 1 – процент от заданного в услуге, 2 –
> абсолютное значение)
>
> *SetPersonalCredit*(**"Логин клиента"**, Алгоритм, размер\_кредита,
> \[дни\_до\_отключения\_кредита\]) // Устанавливает персональный кредит
> (Алгоритм: 0 – Как на текущем тарифе, 1 – процент от заданного в
> тарифе, 2 – абсолютное значение). Если дни до окончания кредита – 0,
> то кредит будет действовать бесконечно.
>
> *GetPersonalCredit*(**"Логин клиента"**) // Возвращает размер
> персонального кредита
>
> *GetPersonalCreditAlgoritm*(**"Логин клиента"**) // Возвращает
> алгоритм персональной абонентской платы (0 – Как на текущем тарифе, 1
> – процент от заданного в тарифе, 2 – абсолютное значение)
>
> *GetMoney*(**"Логин"**) // Выводит баланс клиента
>
> *GetPrevMoney*(**"Логин"**) // Выводит предыдущий баланс клиента (до
> последнего изменения)
>
> *SetMoney*(Сумма,**"Комментарий"**,**"Логин"**,\[**"Логин2"**\],\[**"Логин3"**\],...)
> // Устанавливает баланс клиенту
>
> *AddMoney*(Сумма,**"Комментарий"**,**"Логин"**,\[Слать\_ли\_SMS\_уведомление\],\[Фискализировать\])
> // Пополняет счёт клиента на указанную величину
>
> *GetTraffic*(**"Логин"**) // Выводит наработанный клиентом входящий
> трафик
>
> *GetTrafficOut*(**"Логин"**) // Выводит наработанный клиентом
> исходящий трафик
>
> *GetDayTraffic*(**"Логин"**) // Выводит наработанный за сутки клиентом
> трафик
>
> *GetDayTrafficOut*(**"Логин"**) // Выводит наработанный за сутки
> клиентом трафик
>
> *GetDayTrafficOut*(**"Логин"**) // Выводит наработанный за сутки
> клиентом трафик
>
> *AddBonusDayTraffic*(**"Логин"**,Бонус\_входящего\_трафика\_в\_байтах,
> Бонус\_исходящего\_трафика\_в\_байтах) // Добавляет бонусные мегабайты
> трафика на день абоненту на тарифе с лимитом трафика
>
> *GetMonthTrafficOut*(**"Логин"**) // Выводит наработанный за месяц
> клиентом трафик
>
> *GetDayTrafficLimit*(**"Логин"**) // Выводит порог срабатывания
> ограничений для суточного трафика
>
> *GetMonthTrafficLimit*(**"Логин"**) // Выводит порог срабатывания
> ограничений для месячного трафика
>
> *AddBonusMonthTraffic*(**"Логин"**,Бонус\_входящего\_трафика\_в\_байтах,
> Бонус\_исходящего\_трафика\_в\_байтах) // Добавляет бонусные мегабайты
> трафика на месяц абоненту на тарифе с лимитом трафика
>
> *GetStopTime*(**"Логин"**) // Выводит время остановки клиента
>
> *IsTurbo*(**"Логин"**) // Определяет нажата ли у клиента турбо//кнопка
>
> *GetTurboStartTime*(**"Логин"**) // Выводит время нажатия клиентом
> турбо-кнопки
>
> *GetTurboStopTime*(**"Логин"**) // Выводит время окончания действия
> турбо-кнопки
>
> *AbortTurbo*(**"Логин1"**,\[**"Логин2"**\],\[**"Логин3"**\],...) //
> отменяет нажатие турбо//кнопки у клиентов
>
> *IsPromisePay*(**"Логин"**) // Определяет взят ли у клиента обещанный
> платёж
>
> *GetPromisePayStartTime*(**"Логин"**) // Выводит время взятия клиентом
> обещанного платежа
>
> *GetPromisePayStopTime*(**"Логин"**) // Выводит время окончания
> действия обещанного платежа
>
> *AbortPromisePay* (**"Логин1"**,\[**"Логин2"**\],\[**"Логин3"**\],...)
> // Отменяет обещанный платёж у клиентов
>
> *IsDialIn*(**"Логин"**) // Определяет, является ли клиент DialIn
>
> *GetDialInName*(**"Логин"**) // Выводит тип DialIn
>
> *SetClientDialInName*(**"Логин"**,**"Тип DialIn"**) // Устанавливает
> тип DialIn
>
> *IsLinkedToMikroTik*(**"Логин", "MikroTik ID"**) // Расположен ли
> клиент на MikroTik (здесь MikroTik ID = “IP:порт”, например
> 192.168.1.1:8728)
>
> *WriteToLog* (**"Сообщение"**) - Записать сообщение в лог MikroBILL
> (если в настройках включено ведение логов)
>
> *WriteToFile*(**"Путь к файлу"**,**"Текст"**,\[**"Кодировка"**\]) //
> Добавляет произвольный текст в файл (НЕбезопасная функция, в отличии
> от безопасных позволяет взаимодействовать с любым файлом на HDD).
>
> *KillFile*(**"Путь к файлу"**) // Удаляет файл (НЕбезопасная функция,
> в отличии от безопасных позволяет взаимодействовать с любым файлом на
> HDD).
>
> *GetCountClientsInTarif*(**"Название тарифа"**) // Выводит количество
> клиентов в тарифе
>
> *GetCountClientsInGroup*(**"Название группы"**) // Выводит количество
> клиентов в группе
>
> *GetCountClients*() // Выводит общее количество клиентов в биллинге
>
> *GetClientFromTarif*(**"Название тариф"**, Номер\_клиента) // Выводит
> клиента с заданным номером из выбранного тарифа
>
> *GetClientsFromTarif*(**"Название тарифа ",** Имя\_переменной) //
> Помещает список клиентов, находящихся на тарифе, в массив
>
> *GetClientFromGroup*(**"Название группы"**, Номер\_клиента) // Выводит
> клиента с заданным номером из выбранной группы
>
> *GetClientsFromGroup*(**"Название тарифа"**, Имя\_переменной) //
> Помещает список клиентов, находящихся в группе, в массив
>
> *GetClient*(Номер\_клиента) // Выводит клиента с заданным номером
>
> *GetClients*(Имя\_переменной) // Помещает список клиентов в указанный
> массив
>
> *GetClientName*(**"Логин\_клиента"**) // Выводит имя клиента, заданное
> в MIkroBILL
>
> *SetClientName*(**"Логин\_клиента"**, **"Новое имя клиента"**) //
> Устанавливает имя клиенту
>
> *SetClientLogin*(**"Прежний логин клиента"**, **"Новый логин
> клиента"**) // Устанавливает новый логин клиенту
>
> *Alert*(**"Текст сообщения"**) // Вывод сообщения в диалоговом окне
>
> *GetRxSpeed*(**"Логин"**) // Вывод текущей входящей скорости клиента
>
> *GetTxSpeed*(**"Логин"**) // Вывод текущей исходящей скорости клиента
>
> *RunScript*(**"Имя скрипта",** \[Массив с аргументами\]) // Запуск
> скрипта. Аргументы будут помещены в массив ExtArgs
>
> *Ping*(**"IP или хост"**) // проверяет доступность какого-либо ресурса
>
> *AddToInterfaceBallance*(**"ID подключения к MikroTik"**, **"Имя
> интерфейса"**,**"Огр.вх."** ,**"Огр.Исх."**) // Добавляет интерфейс к
> списку балансировки нагрузки. ID подключения = IP подключения + порт,
> например: 192.168.100.1:8728
>
> *RemoveFromInterfaceBallance*(**"ID подключения к MikroTik"**, **"Имя
> интерфейса "**) // Удаляет интерфейс из списка балансировки нагрузки.
> ID подключения = IP подключения + порт, например: 192.168.100.1:8728
>
> *EnableService*(**"Название\_сервиса"**,**"Логин"**,\[**"Логин2"**\],\[**"Логин3"**\],...)
> // Запускает услугу клиенту
>
> *DisableService*(**"Название\_сервиса"**,**"Логин"**,\[**"Логин2"**\],\[**"Логин3"**\],...)
> // Останавливает услугу клиенту
>
> *IsServiceEnabled*(**"Название\_сервиса"**,**"Логин"**) // Проверяет,
> подключена ли услуга клиенту
>
> *GetEnabledServices* (**"Логин",** Имя\_переменной) // Помещает список
> подключенных клиенту услуг в массив
>
> *GetClientIndex(***"Логин"**) // Получает порядковый номер клиента в
> системе
>
> *GetClientIndexFromTarif*(**"Название тарифа"**, **"Логин
> клиента"**)// Получает порядковый номер клиента в системе исходя из
> номера клиента в тарифе
>
> *GetClientLastActivity*(**"Логин клиента"**) // Получает время
> последней активности клиента
>
> *GetLastPayDate*(**"Логин клиента"**) // Получает время последнего
> пополнения счёта клиентом
>
> *GetClientCreationDate*(**"Логин клиента"**) // Получает время
> создания клиента
>
> *GetState*(**"Логин"**) // Получает статус клиента: доступ разрешён /
> доступ запрещён
>
> *MoveToArchive*(**"Логин
> клиента"**,\[**"Логин2"**\],\[**"Логин3"**\],...) // Отправляет
> клиента в архив
>
> *RemoveFromArchive*(**"Логин
> клиента"**,\[**"Логин2"**\],\[**"Логин3"**\],...) // Удаляет клиента
> из архива
>
> *RemoveFromBlockTarif*(**"Логин
> клиента"**,\[**"Логин2"**\],\[**"Логин3"**\],...) // Возвращает
> клиента с блокирующего тарифа на предыдущий, если на счету клиента
> находится сумма больше значения абонентской платы.
>
> *StartTurbo* (**"Логин"**,\[**"Логин2"**\],\[**"Логин3"**\],...) //
> Запускает турбо-режим у клиента
>
> *StartPromisePay* (**"Логин"**,
> \[**"Название\_обещанного\_платежа"**\]) // Запускает обещанный платёж
> у клиента
>
> *FileLinesCount*(**"Имя файла"**) // Количество строк в файле. Все
> файлы создаются в папке "%allusersprofile%\MikroBILL\Scripts\Files\\
> (безопасная функция).
>
> *ReadFileLine*(**"Имя файла"**,**"Номер строки"**,\[**"Кодировка"**\])
> // Прочитать строку с заданным номером. Все файлы создаются в папке
> "%allusersprofile%\MikroBILL\Scripts\Files\\ (безопасная функция).
>
> *ReadFileToArray*(**"Имя файла",**
> Имя\_переменной,\[**"Кодировка"**\]) // Читает весь файл, помещая
> каждую строку в элемент массива. Все файлы создаются в папке
> "%allusersprofile%\MikroBILL\Scripts\Files\\ (безопасная функция).
>
> *WriteLineInNewFile*(**"Имя файла"**,**"Строка"**,\[**"Кодировка"**\])
> // Создать файл и записать в него строку. Все файлы создаются в папке
> "%allusersprofile%\MikroBILL\Scripts\Files\\ (безопасная функция).
>
> *AppendLineInFile*(**"Имя файла"**,**"Строка"**,\[**"Кодировка"**\])
> // Добавить строку в конец файла. Все файлы создаются в папке
> "%allusersprofile%\MikroBILL\Scripts\Files\\ (безопасная функция).
>
> *DeleteFile*(**"Имя файла"**) // Удалить файл. Файлы удаляются из
> папки "%allusersprofile%\MikroBILL\Scripts\Files\\ (безопасная
> функция).
>
> *GetClientBirthday*(**"Логин"**) // Получает день рождения клиента.
> Для сравнения дат, используйте VBS функцию:
> DateDiff("s",fromDate,toDate)
>
> *SetClientBirthday*(**"Логин"**,**"Дата"**) // Устанавливает день
> рождения клиента
>
> *IsMikroTikConnected*(**"IP:порт"**) // Проверяет подключен ли
> MikroTik
>
> *GetCountMikrotiks*() // Возвращает количество MikroTik, добавленных в
> биллинг
>
> *GetMikrotikName(*Номер\_MikroTik) // Получает идентификатор MikroTik
> (идентификатор = IP: порт)
>
> *GetArraySize(*Имя\_переменной) // Возвращает размер массива
>
> *GetClientAttributes* (**"Логин",** Имя\_переменной) // Помещает
> атрибуты клиента в массив
>
> *SetClientAttributes* (**"Логин",** Имя\_переменной) // Читает
> атрибуты клиента из массива, значения заданные как Nothing обновлены
> не будут
>
> *SetLastSubscriptionFeeTime* (**"Логин"**, **"Дата"**) //
> Устанавливает время последнего списания абонентской платы
>
> *GetDaysBeforeSubscriptionFee* (**"Логин"**) // Возвращает количество
> дней до абонентской платы
>
> *GetClientfID*(**"Логин"**) // Возвращает уникальный идентификатор
> клиента (long)
>
> *GetTarifID*(**"Название тарифа"**) // Возвращает уникальный
> идентификатор тарифа (long)
>
> *GetGroupID*(**"Название группы"**) // Возвращает уникальный
> идентификатор группы (long)
>
> *GetServiceID*(**"Название услуги"**) // Возвращает уникальный
> идентификатор услуги (long) (только для услуг и одноразовых услуг)
>
> *SendMoneyToPhone*(**"Логин",** Сумма) // Переводит деньги со счёта
> абонента на его мобильный телефон (через Qiwi)
>
> *SendMoneyToPhone2*(**"Телефон",** Сумма) // Переводит деньги со счёта
> абонента на его мобильный телефон (через Qiwi)
>
> *GetFeeSize*(**"Логин"**) // Получает размер ежемесячной абонентской
> платы по тарифу
>
> *GetBlockMoneySize* (**"Логин"**) // Получает баланс, при котором
> абонент будет остановлен
>
> *GetBlockReason* (**"Логин"**) // Получает причину остановки клиента
>
> **-1** – Абонент не заблокирован
>
> **0** – Остановлен по балансу
>
> **1** – Нет денег для списания абонентской платы (предоплата)
>
> **2** – Остановлен по датам
>
> **3** – Остановлен администратором
>
> **4** – На блокирующем тарифе
>
> **5** – Абонент добровольно приостановил действие улсуги
>
> **6** – Абонент в архиве
>
> **7** – Отрицательный баланс и нет денег для списания оплаты
> (предоплата)
>
> **8** – Агент авторизации не подключен
>
> **9** – Не принята публичная оферта
>
> *Split* (**"Строка"**, **"Разделитель"**, Имя\_переменной) //
> Разбивает строку и помещает результат в массив
>
> *Join* (Имя\_переменной, Разелитель) // Объединяет массив в строку
>
> *Replace* (**"Исходная\_строка"**, **"Строка\_для\_поиска"**,
> **"Строка\_для\_замены"**) // Производит замену текста в строке
>
> *InStr* (**"Стартовая\_позиция"**, **"Строка\_в\_которой\_ищем"**,
> **"Текст\_который\_ищем"**) // Производит подстроки в строке,
> возвращает позицию начала вхождения
>
> *Mid* (**"Исходная строка"**, Стартовая\_позиция, Длина) // Копирует
> часть строки
>
> *Len* (**"Строка"**) // Возвращает длину строки
>
> *ToUpper* (**"Строка"**) // Преобразовать строку в верхний регистр
>
> *ToLower* (**"Строка"**) // Преобразовать строку в нижний регистр
>
> *Trim* (**"Строка",** \[**"Символ\_обрезки"**\]) // Обрезает текст
>
> *GetRandomString* (Длинна,\[Строка\_с\_набором\_символов\]) //
> Возвращает произвольную строку заданной длинны
>
> *IsAuthorized*(**"Логин клиента"**) // Получает статус авторизации
> клиента
>
> *HttpRequest* (**"URL"**, \[Тип\_запроса\], \[**"Данные"**\],
> \[Заголовки\], \[Тип\_контента\]) // Выполняет http или https запрос,
> возвращает полученные данные.
>
> **Тип запроса:**
>
> **0** – GET (по умолчанию)
>
> **1** – POST
>
> **2** – PUT
>
> **3** – PATCH
>
> **4** - DELETE
>
> **Данные:** Любые данные в виде строки, передаваемые в теле запроса.
>
> **Заголовки:** Массив, в элементах которого попарно содержатся
> заголовки и значения, например:
>
> **Arr\[0\] =** "Authorization"
>
> **Arr\[1\] =** "Bearer jhjlajgkjfbdsbf3t5"
>
> **Типы контента:**
>
> **0 -** application/x-www-form-urlencoded (по умолчанию)
>
> **1 -** application/json
>
> **2 -** text/xml
>
> *EscapeUriString*(**"URL"**) // Экранирует параметр http строки,
> например, «Ivanov Ivan» будет преобразовано в «Ivanov%20Ivan»
>
> *RexExpExecute* (**"Проверяемая\_строка"**, **"Шаблон"**,
> **\[**Массив\_для\_результатов\], \[Массив\_с\_позициями\_в\_строке\])
> // Проверка по регулярному выражению. Возвращает False или True
>
> *Sleep(*Пауза\_в\_миллисекундах) // Задержка выполнения скрипта на
> заданное время
>
> *Exec(***"Путь"**,**"Аргументы"**, Ожидание, Скрыть\_Окно) //
> Запускает произвольный исполняемый файл. Ожидание = True/False,
> показывает, нужно ли ожидать завершения. Скрыть\_окно = True/False.
>
> *Push* (Имя\_массива, **"Значение"**) // Добавить элемент в конец
> массива
>
> *ArraySearch* (Имя\_массива, **"Значение"**) // Возвращает False или
> True в зависимости от того, присутствует ли элемент в массиве.
>
> *MD5* (**"Строка"**) // Возвращает MD5 хэш.
>
> *SHA1* (**"Строка"**) // Возвращает SHA хэш.
>
> *ToUnixTime* (Дата) // Возвращает метку времени UNIX.
>
> *FromUnixTime* (UNIXTIME) // Возвращает время из метку времени UNIX.
>
> *ToBase64* (**"Строка"**) // Переводит строку в BASE64.
>
> *FromBase64* (**"Строка"**) // Переводит BASE64 в строку.
>
> *Now*() // Возвращает текущее время.
>
> *Today*() // Возвращает текущую дату.
>
> *Weekday*() // Возвращает день недели.
>
> *Hour*(Дата) // Возвращает час.
>
> *Minute*(Дата) // Возвращает минуту.
>
> *Second*(Дата) // Возвращает секунду.
>
> *Year*(Дата) // Возвращает год.
>
> *Month*(Дата) // Возвращает месяц.
>
> *Day*(Дата) // Возвращает число месяца.
>
> *IgnoreErrors* // Игнорирование ошибок в скрипте
>
> **Обратите внимание!**

1.  Все функции, возвращающие дату, возвращают дату в американском
    формате, т.е.: MM/dd/yyyy HH:mm:ss

2.  Безопасные файловые функции работают с файлами, находящимися в папке
    %allusersprofile%\Scripts\Files\\

**Порядок формирования параметра «Набор столбцов» для функций
MakeDataExport и MakeDataImport**

Параметр «Набор столбцов» - строка, состоящая из идентификаторов
столбцов, разделённых запятой. Ниже представлены столбцы и их
идентификаторы.

Например, для выгрузки логина абонента и его баланса параметр «Набор
столбцов» должен быть равен «7,4»

Чтобы узнать идентификаторы дополнительных полей, вам нужно зайти в БД
MySQL, например, при помощи HeidiSQL, и открыть таблицу fields. Параметр
– id.

Клиент - 0

Тариф - 1

Предыдущий тариф - 2

Группа - 3

Баланс - 4

Дата 1 - 5

Дата 2 - 6

Логин - 7

Пароль - 8

Трафик, Мб. - 9

IP - 10

IP для PPP - 11

MAC - 12

Скорость, Кбит/с - 13

Дни - 14

Ограничения, Кбит/с - 15

Телефон - 16

ФИО - 17

Активность - 18

Пополнение - 19

Отключение - 20

Договор - 21

Адрес - 22

Адрес 2 - 48

Примечание 1 - 23

Примечание 2 - 24

Примечание 3 - 25

Примечание 4 - 47

Комментарий для IP - 42

MikroTik - 26

Почта - 27

Следующий тариф - 28

Изменение тарифа - 29

Создан - 30

В архиве - 31

Авторизован на - 32

Месячный трафик начало - 33

Остановка при - 34

Персональная абонентская плата - 35

Последняя абонентская плата - 36

Интерфейс - 37

Время остановки - 38

Имя хоста - 39

Тип подключения - 40

Кредит - 41

Интерфейс балансировки - 43

Подключенные услуги - 44

Окончание турбо - 45

Окончание обещ.платежа - 46

PPP аптайм - 49

Персональное сообщение - 50

Персональное сообщение 2 - 51

Услуги и абон. плата - 52

Время расчёта - 53

Статус - 54

Порядковый номер абонента - 55

Порядковый номер тарифа - 56

Порядковый номер группы - 57

Списание оплаты - 58

ICQ - 59

Skype - 60

Email - 61

Паспорт – 62

<span class="mark">Онлайн</span> - 63

<span class="mark">WEB-авторизация завершение</span> – 64

Бонусный трафик - 65

<span class="mark">Причина остановки</span> - 66

<span class="mark">Рекомендуемый платёж</span> - 67

<span class="mark">Следующая абонентская плата</span> - 68

<span class="mark">SmotreshkaID</span> - 69

<span class="mark">TVh24ID</span> - 70

<span class="mark">OmegaTV ID</span> - 71

<span class="mark">TrinitY.TV ID</span> - 72

<span class="mark">Директор</span> - 73

<span class="mark">Организация</span> - 74

<span class="mark">Юр. Адрес</span> – 75

<span class="mark">Банк</span> - 76

<span class="mark">Р/С</span> - 77

<span class="mark">ИНН</span> - 78

<span class="mark">БИК</span> - 79

<span class="mark">Кем выдан паспорт</span> - 80

<span class="mark">Дата получения паспорта</span> – 81

<span class="mark">Код подразделения выдавшего паспорт</span> - 82

<span class="mark">Серия паспорта</span> - 83

<span class="mark">Номер паспорта</span> - 84

<span class="mark">Дата рождения</span> - 85

<span class="mark">Место рождения</span> – 86

Prosto.TV ID – 87

Megogo.TV ID – 88

Причина недоступности обещанного платежа – 89

Уникальный идентификатор абонента - 90

IPTVPORTAL ID – 91

SweetTV ID - 92

ОГРН - 93

Л/С - 94

К/С - 95

КПП - 96

Контактное Лицо - 97

Почтовый адрес - 98

Адрес для счетов – 99

Включен/выключен – 100

Алгоритм персонального кредита – 101

Алгоритм персональной абонентской платы – 102

Телефон домашний – 103

Групповой счёт - 104

CallerID – 105

Персональный день абон.платы – 106

Запланирована оплата по тарифу – 107

Запланирована оплата по услугам – 108

Включена рассылка в мессенджеры – 109

UserSide ID – 110

Почтовый индекс - 111

IPTVmedia ID – 112

Оферта принята – 113

ID языка WEB – 114

MooviTV ID - 117
